"""Handles the management of databases"""
import os
from typing import Tuple
import sqlite3
import psycopg2
import psycopg2.extras
from modules.data.data_reader import get_abs_path, read_file, config_map


def dict_factory(cursor: sqlite3.Cursor, row: sqlite3.Row) -> dict:
    """Make so that the cursor is a list of dictionaries with column names as keys

    Args:
        cursor (sqlite3.Cursor): cursor generated by the database
        row (sqlite3.Row): rows of the database

    Returns:
        dict: structure of the database used used by the cursor
    """
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


class DbManager():
    """Class that handles the management of databases
    """
    use_remote_db = config_map['data']['remote']

    @staticmethod
    def get_db() -> Tuple[sqlite3.Connection, sqlite3.Cursor]:
        """Create the connection to the database. It can be sqlite or postgres

        Returns:
            Tuple[sqlite3.Connection, sqlite3.Cursor]: sqlite database connection and cursor
            Tuple[psycopg2.Connection, psycopg2.Cursor]psycopg2.connection: postgres database connection and cursor
        """
        if DbManager.use_remote_db:  # connect to the remote db
            db_path = os.environ.get("DATABASE_URL", config_map['data']['db_url'])
            conn = psycopg2.connect(db_path, sslmode='require')
            cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        else:  # connect to the local db
            db_path = get_abs_path("data", "db", "sqlite.db")
            conn = sqlite3.connect(db_path)
            conn.row_factory = dict_factory
            cur = conn.cursor()
        return conn, cur

    @staticmethod
    def query_from_file(*file_path: str):
        """Commit all the queries in the specified file. The queries must be separated by a ----- string

        Args:
            file_path (str): path of the text file containing the queries
        """
        conn, cur = DbManager.get_db()
        queries = read_file(*file_path).split("-----")
        for query in queries:
            cur.execute(query)
        conn.commit()
        cur.close()
        conn.close()

    @staticmethod
    def query_from_string(*queries: str):
        """Commit all the queries in the string
        Should not be used to select something

        Args:
            queries (str): tuple of queries
        """
        conn, cur = DbManager.get_db()
        for query in queries:
            cur.execute(query)

        conn.commit()
        cur.close()
        conn.close()

    @staticmethod
    def select_from(table_name: str, select: str = "*") -> list:
        """Returns the result of a SELECT select FROM table_name

        Args:
            table_name (str): name of the table used in the FROM
            select (str, optional): [description]. Defaults to "*".

        Returns:
            list: result of the select
        """
        conn, cur = DbManager.get_db()
        try:
            cur.execute(f"SELECT {select} FROM {table_name}")
        except sqlite3.Error as e:
            print("[error] select_star_from: " + str(e))
        query_result = cur.fetchall()
        cur.close()
        conn.close()
        return query_result

    @staticmethod
    def select_from_where(table_name: str, where: str, select: str = "*") -> list:
        """Returns the result of a SELECT select FROM table_name WHERE where

        Args:
            table_name (str): name of the table used in the FROM
            where (str): where clause
            select (str, optional): [description]. Defaults to "*".

        Returns:
            list: result of the select
        """
        conn, cur = DbManager.get_db()
        try:
            cur.execute(f"SELECT {select} FROM {table_name} WHERE {where}")
        except sqlite3.Error as e:
            print("[error] select_start_from_where: " + str(e))
        query_result = cur.fetchall()
        cur.close()
        conn.close()
        return query_result

    @staticmethod
    def count_from_where(table_name: str, where: str) -> int:
        """Returns the number of rows from SELECT COUNT(*) FROM table_name WHERE where

        Args:
            table_name (str): name of the table used in the FROM
            where (str): where clause

        Returns:
            int: number of rows
        """
        conn, cur = DbManager.get_db()
        try:
            cur.execute(f"SELECT COUNT(*) as number FROM {table_name} WHERE {where}")
        except sqlite3.Error as e:
            print("[error] select_start_from_where: " + str(e))
        query_result = cur.fetchall()
        cur.close()
        conn.close()
        return query_result[0]['number']
